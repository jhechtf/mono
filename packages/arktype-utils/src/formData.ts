// eslint-disable-next-line @typescript-eslint/no-unused-vars
import type { Type } from 'arktype';

type EntriesTouple = [string, FormDataEntryValue];

type FilterFn = (a: EntriesTouple) => boolean;

type FormDataObjectEntry = FormDataEntryValue | number | boolean | bigint;

const digitCheck = /^\d+$/;

type MagicObject = {
  readonly type: 'array' | 'object';
  add(key: string, value: string | File): void;
  toJS(): unknown[] | Record<string, unknown>;
};

function makeMagicObject(init: EntriesTouple[] = []): MagicObject {
  const entries: EntriesTouple[] = ([] as EntriesTouple[]).concat(init);
  return {
    get type() {
      if (entries.every(([k]) => digitCheck.test(k) || k === ''))
        return 'array';
      return 'object';
    },
    add(key: string, value: string | File) {
      entries.push([key, value]);
    },
    toJS() {
      // TODO: Figure out how to clean this up
      if (this.type === 'array') {
        const arr: unknown[] = [];
        for (const [k, v] of entries) {
          if (k === '')
            arr.push(typeof v === 'string' ? stringToJSValue(v) : v);
          else arr[Number(k)] = typeof v === 'string' ? stringToJSValue(v) : v;
        }
        return arr;
      }
      const ret: Record<string, unknown> = {};
      for (const [k, v] of entries)
        ret[k] = typeof v === 'string' ? stringToJSValue(v) : v;
      return ret;
    },
  };
}

/**
 *
 * @param fd the form data object
 * @param filterFn an optional filtering function to remove some values from the end object
 * @returns an object mapped from the entries.
 */
function parseKeyPath(key: string): (string | number)[] {
  // Split on dots not inside brackets, then handle bracketed indices/keys
  const path: (string | number)[] = [];
  let buffer = '';
  let inBracket = false;
  for (let i = 0; i < key.length; i++) {
    const [char] = key;
    if (char === '[') {
      if (buffer) {
        path.push(buffer);
        buffer = '';
      }
      inBracket = true;
    } else if (char === ']') {
      if (buffer) {
        // If it's a number, treat as array index
        if (/^\d+$/.test(buffer)) path.push(Number(buffer));
        else path.push(buffer);
        buffer = '';
      } else {
        // Support for [] as array push
        path.push('');
      }
      inBracket = false;
    } else if (char === '.' && !inBracket) {
      if (buffer) {
        path.push(buffer);
        buffer = '';
      }
    } else buffer += char;
  }
  if (buffer) path.push(buffer);
  return path;
}

/**
 * Recursively sets a value in a nested object/array structure based on a path.
 * Handles creation of arrays/objects as needed for deep assignment.
 * Supports array push (''), numeric indices, and string keys.
 *
 * @param obj The root object or array to mutate
 * @param path The path array (from parseKeyPath)
 * @param value The value to set
 */
function setDeep(
  obj: Record<string, unknown> | unknown[],
  path: (string | number)[],
  value: unknown,
) {
  // Full disclosure: this was generated by AI. Should probably deep dive into it
  // in the future but for right now it works.
  let curr: Record<string, unknown> | unknown[] = obj;
  for (let i = 0; i < path.length - 1; i++) {
    const { [i]: key } = path;
    const { [i + 1]: nextKey } = path;
    // Handle array push (''), numeric index, or string key
    if (key === '') {
      if (!Array.isArray(curr)) curr = [];
      const arr = curr as unknown[];
      if (!arr[arr.length - 1] || typeof nextKey === 'string') arr.push({});
      const [last] = arr.slice(-1);
      curr =
        Array.isArray(last) || typeof last === 'object'
          ? (last as Record<string, unknown> | unknown[])
          : {};
    } else if (typeof key === 'number') {
      if (!Array.isArray(curr)) curr = [];
      const arr = curr as unknown[];
      if (!arr[key]) arr[key] = typeof nextKey === 'number' ? [] : {};
      const { [key]: next } = arr;
      curr =
        Array.isArray(next) || typeof next === 'object'
          ? (next as Record<string, unknown> | unknown[])
          : {};
    } else if (typeof key === 'string') {
      if (!(typeof curr === 'object' && curr !== null && key in curr)) {
        (curr as Record<string, unknown>)[key] =
          typeof nextKey === 'number' ? [] : {};
      }
      const objRec = curr as Record<string, unknown>;
      const { [key]: next } = objRec;
      curr =
        Array.isArray(next) || typeof next === 'object'
          ? (next as Record<string, unknown> | unknown[])
          : {};
    }
  }
  const [lastKey] = path.slice(-1);
  if (lastKey === '') {
    if (!Array.isArray(curr)) curr = [];
    (curr as unknown[]).push(value);
  } else if (typeof lastKey === 'number') {
    if (!Array.isArray(curr)) curr = [];
    (curr as unknown[])[lastKey] = value;
  } else if (typeof lastKey === 'string')
    (curr as Record<string, unknown>)[lastKey] = value;
}

/**
 * Converts a FormData object into a deeply nested JavaScript object.
 * Supports dot and bracket notation for nested objects/arrays, e.g.:
 *   - 'foo.bar' → { foo: { bar: value } }
 *   - 'arr[]' → { arr: [value, ...] }
 *   - 'obj[key]' → { obj: { key: value } }
 *   - 'arr[].prop' → { arr: [{ prop: value }, ...] }
 * Handles type conversion for numbers, booleans, and bigints.
 *
 * @param fd The FormData instance
 * @param filterFn Optional filter function for entries
 * @returns The resulting JS object
 */
export function formDataToObject(
  fd: FormData,
  filterFn: FilterFn = () => true,
) {
  const ret: Record<string, unknown> = {};
  // For grouping array objects by their base path
  const arrayGroups = new Map<
    string,
    { current: Record<string, unknown>; arr: Record<string, unknown>[] }
  >();
  // For collecting repeated simple keys and top-level arrays
  const simpleArrays = new Map<string, unknown[]>();
  for (const [rawKey, value] of fd.entries()) {
    if (!filterFn([rawKey, value])) continue;
    const path = parseKeyPath(rawKey);
    let v: unknown = value;
    if (typeof value === 'string') v = stringToJSValue(value);
    // Handle top-level arrays (e.g., names[])
    if (path.length === 2 && path[1] === '') {
      const key = String(path[0]);
      if (!simpleArrays.has(key)) simpleArrays.set(key, []);
      simpleArrays.get(key)!.push(v);
      continue;
    }
    // Handle nested arrays (e.g., locations[].members[])
    const arrayIdx = path.findIndex((p) => p === '');
    if (arrayIdx !== -1) {
      const basePath = path.slice(0, arrayIdx).join('.');
      if (!arrayGroups.has(basePath))
        arrayGroups.set(basePath, { current: {}, arr: [] });
      const group = arrayGroups.get(basePath)!;
      // If this is a new object in the array, push current and start new
      if (
        Object.keys(group.current).length > 0 &&
        path[arrayIdx + 1] === 'name'
      ) {
        group.arr.push(group.current);
        group.current = {};
      }
      // If the property is a nested array (e.g., members[]), collect as array
      if (path.length === arrayIdx + 3 && path[arrayIdx + 2] === '') {
        const prop = String(path[arrayIdx + 1]);
        if (!Array.isArray(group.current[prop])) group.current[prop] = [];
        (group.current[prop] as unknown[]).push(v);
      } else setDeep(group.current, path.slice(arrayIdx + 1), v);
    } else {
      // For repeated simple keys (not arrays)
      const keyStr = path.join('.');
      if (fd.getAll(rawKey).length > 1) {
        if (!simpleArrays.has(keyStr)) {
          simpleArrays.set(
            keyStr,
            fd
              .getAll(rawKey)
              .map((val) =>
                typeof val === 'string' ? stringToJSValue(val) : val,
              ),
          );
        }
      } else setDeep(ret, path, v);
    }
  }
  // Assign grouped arrays
  for (const [base, { current, arr }] of arrayGroups.entries()) {
    if (Object.keys(current).length > 0) arr.push(current);
    setDeep(ret, base.split('.'), arr);
  }
  // Assign simple arrays
  for (const [key, arr] of simpleArrays.entries()) setDeep(ret, [key], arr);
  return ret;
}

// Sometimes Files are weenies
type NonFileFormEntries<T> = T extends File ? never : T;

/**
 * @todo Remove the FormDataEntryValue from this return type. That code is not handled here
 * @param str a string value to be turned into a JS value
 * @returns
 */
function stringToJSValue(str: string): NonFileFormEntries<FormDataObjectEntry> {
  if (/^(?:\+|-)?\d+(?:\.\d+)?$/.test(str) && str < '9007199254740991')
    return Number(str);

  if (/^true|false$/.test(str)) return str === 'true';

  if (/^\d+n$/.test(str) || (str > '9007199254740991' && /^\d+$/.test(str)))
    return BigInt(str.charAt(str.length - 1) === 'n' ? str.slice(0, -1) : str);

  return str;
}

/**
 *
 * @param fd Form Data object
 * @param obj an ArkType type validator
 * @param filterFn Filter function to run when creating the form data object
 * @throws {Problems}
 * @returns
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function validateFormData<T extends Type<any, any>>(
  fd: FormData,
  obj: T,
  filterFn?: FilterFn,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
): T['infer'] {
  const fdo = formDataToObject(fd, filterFn);
  return obj.assert(fdo);
}

// This section is here because I don't want to publish the makeMagicObject function
// But I should still test it
if (import.meta.vitest) {
  const { it, expect, describe } = import.meta.vitest;
  describe('makeMagicObject', () => {
    it('Correctly interprets arrays without keys', () => {
      const obj = makeMagicObject();
      obj.add('', 'bob');
      obj.add('', 'jon');

      expect(obj.type).toBe('array');
      expect(obj.toJS()).toStrictEqual(['bob', 'jon']);
    });

    it('Correctly interprets arrays with keys', () => {
      const obj = makeMagicObject();
      obj.add('0', 'bob');
      obj.add('2', 'jon');
      obj.add('4', 'dave');

      expect(obj.type).toBe('array');
      expect(obj.toJS()).toEqual(['bob', undefined, 'jon', undefined, 'dave']);
    });

    it('Correctly interprets objects', () => {
      const obj = makeMagicObject([
        ['1', 'jim'],
        ['fred', 'and george'],
      ]);
      expect(obj.type).toBe('object');
      expect(obj.toJS()).toEqual({
        '1': 'jim',
        fred: 'and george',
      });
    });
  });
}
